<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/zeno.png?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Zeno Tian">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Zeno Tian">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zeno Tian">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/3/"/>


  <title> Zeno Tian </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Zeno Tian</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/11/ES6-Class/" itemprop="url">
                  Class
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-11T11:07:35+08:00" content="2016-11-11">
              2016-11-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>阅读阮一峰老师的ES6入门的学习笔记。</p>
<h1 id="Class-基本语法"><a href="#Class-基本语法" class="headerlink" title="Class 基本语法"></a>Class 基本语法</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>class</code>关键字，可以看做语法糖。大部分功能ES5通过构造函数生成新对象都可以完成。<code>class</code>写法让对象原型的写法更清晰。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x;</div><div class="line">  <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="与ES5构造函数比较"><a href="#与ES5构造函数比较" class="headerlink" title="与ES5构造函数比较"></a>与ES5构造函数比较</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p><code>class Point</code>等价于<code>function Point</code></p>
</li>
<li><p><code>constructor</code>是构造方法，等价于ES5中构造函数内定义的内容</p>
</li>
<li><p><code>this</code>与ES5一样，代表实例对象</p>
</li>
<li><p>定义“类”的方法不需要加上<code>function</code>关键字，直接写函数名以及函数体。与ES5在构造函数的 <strong>原型对象</strong> 上(<code>Point.prototype</code>)上定义方法</p>
</li>
<li><p>“类”的方法之间不需要逗号分隔</p>
</li>
<li><p>可以使用<code>Object.assign</code>方法，一次向类添加多个方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</div><div class="line">  toString()&#123;&#125;,</div><div class="line">  toValue()&#123;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>与ES5构造函数一样，通过<code>new</code>命令创造实例对象</p>
</li>
<li><p>与ES5 <strong>不同</strong> 类内部定义的方法是不可枚举的 （non-enumerable）</p>
</li>
<li><p>类的构造函数，不使用<code>new</code>无法调用。ES5中构造函数可以不通过<code>new</code>调用</p>
</li>
<li><p>ES6 不存在变量提升所以需要先声明父类再使用</p>
</li>
<li><p>“类”的属性名，可以采用表达式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> methodName = <span class="string">"getArea"</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(length) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  [methodName]() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>与构造函数相同<code>typeof</code>为<code>function</code></li>
<li><code>Point.prototype.constructor</code>也为自身</li>
</ul>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><ul>
<li>类的默认方法，通过<code>new</code>生成对象实例时自动调用。</li>
<li>没有定义时，会默认添加空的<code>constructor</code>方法</li>
<li>默认返回对象实例（<code>this</code>）也可以返回别的对象</li>
<li>类的构造函数，不使用<code>new</code>无法调用。</li>
</ul>
<h2 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h2><ul>
<li>与ES5相同，实例的属性除非显示的定义在<code>this</code>上，否则都是定义在原型上<code>class</code>上</li>
<li>与ES5相同，类的所有实例共享同一个原型对象</li>
</ul>
<h2 id="Class表达式"><a href="#Class表达式" class="headerlink" title="Class表达式"></a>Class表达式</h2><ul>
<li><p>和函数一样可以使用表达式形式定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</div><div class="line">  getClassName() &#123;</div><div class="line">    <span class="keyword">return</span> Me.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>类的名字是<code>MyClass</code></li>
<li><code>Me</code>只能在Class内部可用</li>
<li><code>Me</code>和函数名一样，可以省略</li>
</ul>
</li>
<li><p>​</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/09/gitignore配置文件/" itemprop="url">
                  gitignore配置规则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-09T16:16:32+08:00" content="2016-11-09">
              2016-11-09
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="gitignore配置文件"><a href="#gitignore配置文件" class="headerlink" title=".gitignore配置文件"></a>.gitignore配置文件</h1><h2 id="gitignore忽视规则"><a href="#gitignore忽视规则" class="headerlink" title=".gitignore忽视规则"></a>.gitignore忽视规则</h2><ul>
<li><p>#号开始代表注释</p>
</li>
<li><p>/号代表当前目录（最开始）</p>
</li>
<li><p>!号后面的已被前面忽视规则忽视的文件或目录被排除出忽视</p>
</li>
<li><p>后缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*.a</div><div class="line">#忽视已a为后缀的文件</div><div class="line">*.[ab]</div><div class="line">#忽视已.a以及.b为后缀的文件</div></pre></td></tr></table></figure>
</li>
<li><p>文件及目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">abc</div><div class="line">#忽视abc文件以及acb目录</div><div class="line">abc/</div><div class="line">#忽视abc目录</div><div class="line">/abc/忽视配置不生效的问题</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="忽视配置不生效的问题"><a href="#忽视配置不生效的问题" class="headerlink" title="忽视配置不生效的问题"></a>忽视配置不生效的问题</h2><p>在开发过程中经常会有需要将已经追踪过的文件添加为忽略文件，但是直接配置.gitignore文件是不会生效的。这时候需要先把本地缓存删除然后再提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rm -r --cached .</div></pre></td></tr></table></figure>
<h2 id="强制添加已被忽略文件"><a href="#强制添加已被忽略文件" class="headerlink" title="强制添加已被忽略文件"></a>强制添加已被忽略文件</h2><p>想要添加文件到Git但是已经被忽略的，可以通过<code>-f</code>强制添加到Git</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add -f filename</div></pre></td></tr></table></figure>
<p>或者想修改<code>.gitignore</code>规则，可以使用<code>git check-ignore</code>命令检查当前文件是被<code>.gitingore</code>哪里的配置忽略掉的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git check-ignore -v filename</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/09/Redux/" itemprop="url">
                  redux基础学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-09T12:01:00+08:00" content="2016-11-09">
              2016-11-09
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>Redux可预测的JavaScript应用程序的状态容器</p>
<p>帮助你写的应用行为一致，在不同的环境（client, server,native），更容易测试，提供更好的开发体验。</p>
<h2 id="Start—React-Redux"><a href="#Start—React-Redux" class="headerlink" title="Start—React-Redux"></a>Start—React-Redux</h2><p>安装依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install --save redux react-redux</div><div class="line">npm install --save-dev redux-devtools</div></pre></td></tr></table></figure>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>应用程序的整个状态存储在单个存储中的对象树中。（Redux状态容器中）</li>
<li>改变状态树的唯一方法是发出一个动作<code>action</code>，一个描述发生了什么的对象。</li>
<li>要指定动作<code>action</code>如何操作了状态树，需要自己编写<code>reducer</code></li>
</ul>
<h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><p><code>reducer</code>一个纯函数用于<code>(state, action) =&gt; state</code></p>
<p>描述了一个<code>action</code>如何将<code>state</code>转换为下一个<code>state</code></p>
<p>状态的类型（形式）取决与你自己：它可以是基本类型，一个数组，一个对象，一个<code>Immutable.js</code>数据结构。</p>
<p>重要的一点是，你不应该改变状态对象（修改state），如何<code>state</code>改变了，将会返回一个新的对象。</p>
<h2 id="三原则"><a href="#三原则" class="headerlink" title="三原则"></a>三原则</h2><ul>
<li><h3 id="单一来源"><a href="#单一来源" class="headerlink" title="单一来源"></a>单一来源</h3></li>
</ul>
<p>整个应用程序的状态存储在单个存储中的对象树中。</p>
<ul>
<li><h3 id="state只读"><a href="#state只读" class="headerlink" title="state只读"></a><code>state</code>只读</h3></li>
</ul>
<p>改变状态的唯一方法是发出一个<code>action</code>，一个描述发生了什么的对象</p>
<ul>
<li><h3 id="使用纯函数进行更改"><a href="#使用纯函数进行更改" class="headerlink" title="使用纯函数进行更改"></a>使用纯函数进行更改</h3></li>
</ul>
<p>要指定如何通过操作转换状态树，可以编写纯reducer。</p>
<p>编写纯函数<code>reducer</code></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><h4 id="Actions-1"><a href="#Actions-1" class="headerlink" title="Actions"></a>Actions</h4><p><code>Actions</code>是将数据从应用程序发送到<code>store</code>的行为。他们是<code>store</code>的唯一信息来源。您可以使用store.dispatch（）将它们发送到<code>store</code>。</p>
<p><code>action</code>是纯JavaScript对象。<code>action</code>必须具有指示要执行的操作类型的type属性。类型通常应定义为字符串常量。一旦应用程序足够大，可以将它们移动到一个单独的模块。</p>
<p>每个<code>action</code>尽量减少数据 </p>
<h4 id="Action-Creators"><a href="#Action-Creators" class="headerlink" title="Action Creators"></a>Action Creators</h4><p><code>Action Creators</code>创建<code>actiuon</code>的函数，返回<code>action</code>。更容易测试</p>
<p>传统<code>fulx</code>中，<code>dispatch</code>通常在<code>action Creators</code>函数调用时触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function addTodoWithDispatch(text) &#123;</div><div class="line">  const action = &#123;</div><div class="line">    type: ADD_TODO,</div><div class="line">    text</div><div class="line">  &#125;</div><div class="line">  dispatch(action)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Redux</code>中，进行分发，需要将<code>Action Creators</code>函数返回的结果传入<code>dispatch()</code>中</p>
<p>例如<code>dispath(actionCreators(arg))</code></p>
<h3 id="Reducers"><a href="#Reducers" class="headerlink" title="Reducers"></a>Reducers</h3><h4 id="Reducers-1"><a href="#Reducers-1" class="headerlink" title="Reducers"></a>Reducers</h4><p>操作描述了事情发生的事实，但不指定应用程序的状态如何变化。</p>
<h4 id="Designing-the-State-Shape-设计state"><a href="#Designing-the-State-Shape-设计state" class="headerlink" title="Designing the State Shape/设计state"></a>Designing the State Shape/设计state</h4><p>应用的状态全部存储在单一的对象中，那么响应UI的状态如何做到最小？</p>
<p>state的状态应该使用ID进行存储，区分。更方便使用。</p>
<h4 id="处理-Actions"><a href="#处理-Actions" class="headerlink" title="处理 Actions"></a>处理 Actions</h4><p><code>reduce</code>接收<code>action</code>和先前的<code>state</code>和动作，并返回下一个状态。</p>
<h4 id="Reduce中不能进行的操作"><a href="#Reduce中不能进行的操作" class="headerlink" title="Reduce中不能进行的操作"></a>Reduce中不能进行的操作</h4><ul>
<li>修改参数</li>
<li>执行次要操作，例如：API调用，路由转换</li>
<li>调用非纯函数：<code>Date.now()</code>或<code>Math.random()</code></li>
</ul>
<p><code>reduce</code>应该是一个纯函数，输入相同返回应该相同</p>
<h6 id="NOTE-不要修改旧的state"><a href="#NOTE-不要修改旧的state" class="headerlink" title="NOTE 不要修改旧的state,"></a>NOTE 不要修改旧的state,</h6><h4 id="Splitting-Reducers-分割Reducers"><a href="#Splitting-Reducers-分割Reducers" class="headerlink" title="Splitting Reducers 分割Reducers"></a>Splitting Reducers 分割Reducers</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> SET_VISIBILITY_FILTER:</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">        <span class="attr">visibilityFilter</span>: action.filter</div><div class="line">      &#125;)</div><div class="line">    <span class="keyword">case</span> ADD_TODO:</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">        <span class="attr">todos</span>: [</div><div class="line">          ...state.todos,</div><div class="line">          &#123;</div><div class="line">            <span class="attr">text</span>: action.text,</div><div class="line">            <span class="attr">completed</span>: <span class="literal">false</span></div><div class="line">          &#125;</div><div class="line">        ]</div><div class="line">      &#125;)</div><div class="line">    <span class="keyword">case</span> TOGGLE_TODO:</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">        <span class="attr">todos</span>: state.todos.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> &#123;</div><div class="line">          <span class="keyword">if</span>(index === action.index) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, todo, &#123;</div><div class="line">              <span class="attr">completed</span>: !todo.completed</div><div class="line">            &#125;)</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> todo</div><div class="line">        &#125;)</div><div class="line">      &#125;)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = [], action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> ADD_TODO:</div><div class="line">      <span class="keyword">return</span> [</div><div class="line">        ...state,</div><div class="line">        &#123;</div><div class="line">          <span class="attr">text</span>: action.text,</div><div class="line">          <span class="attr">completed</span>: <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    <span class="keyword">case</span> TOGGLE_TODO:</div><div class="line">      <span class="keyword">return</span> state.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span> (index === action.index) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, todo, &#123;</div><div class="line">            <span class="attr">complate</span>: !todo.complate</div><div class="line">          &#125;)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> todo</div><div class="line">      &#125;)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">visibilityFilyer</span> (<span class="params">state = SHOW_ALL, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> SET_VISIBILITY_FILTER:</div><div class="line">      <span class="keyword">return</span> action.filter</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">todoApp</span> (<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">visibilityFilter</span>: visibilityFilter(state.visibilityFilter, action),</div><div class="line">    <span class="attr">todos</span>: todos(state.todos, action)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将<code>state</code>切片化。reduce组合是构建Redux应用程序的基本模式。</p>
<p>每个<code>reduce</code>只管理<code>state</code>的一部分。</p>
<p><code>Redux</code>提供<code>combineReducers（）</code>方法，可以拆分<code>Reducer</code></p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><h4 id="Store的职责"><a href="#Store的职责" class="headerlink" title="Store的职责"></a><code>Store</code>的职责</h4><ul>
<li>管理 app state</li>
<li>通过 <code>getstate()</code> 访问state</li>
<li>通过 <code>dispath(action)</code> 更新state</li>
<li>注册监听器 <code>subscrive(listener)</code></li>
<li>通过subscribe（listener）返回的函数处理监听器的注销。</li>
</ul>
<p>一个app只能有一个<code>store</code></p>
<h2 id="Date-Flow-数据流"><a href="#Date-Flow-数据流" class="headerlink" title="Date Flow 数据流"></a>Date Flow 数据流</h2><p>Redux应用程序中的数据生命周期都遵循以下4个步骤</p>
<ul>
<li><strong>调用</strong> <a href="http://redux.js.org/docs/api/Store.html#dispatch" target="_blank" rel="external"><code>store.dispatch(action)</code></a>.</li>
</ul>
<p>动作是描述发生了什么的简单对象，可以在任何地方调用</p>
<ul>
<li><code>Store</code>调用传入的<code>reduce</code></li>
<li>根<code>reduce</code>可以将多个<code>reduce</code>组合成一个状态树</li>
<li><p><code>store</code>将根<code>reduce</code>返回的对象作为状态存储</p>
<p><code>subscribe</code>订阅取消订阅问题？？</p>
</li>
</ul>
<ul>
<li>创建store：<code>let store = createStore(todoApp)</code> 传入<code>reduce</code></li>
<li>执行订阅：返回值为取消订阅函数，执行reduce后触发回调？</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></div><div class="line">  <span class="built_in">console</span>.log(store.getState())</div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>触发<code>dispatch</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.dispatch(addTodo(<span class="string">'Learn about actions'</span>))</div></pre></td></tr></table></figure>
<p>接收<code>action</code></p>
<h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><h3 id="Actions-2"><a href="#Actions-2" class="headerlink" title="Actions"></a>Actions</h3><p>异步最重要的两个时间点：发送异步请求和接受到响应</p>
<p>两个时间点都需要改变应用状态，调用reducer。通常需要三种不同的操作</p>
<ul>
<li><strong>An action informing the reducers that the request began</strong>通知<code>reducers</code>异步操作开始</li>
</ul>
<p><code>reducers</code>修改状态为<code>isFetching</code>，UI显示微调框</p>
<ul>
<li><strong>An action informing the reducers that the request finished successfully.</strong>通知<code>reducers</code>请求完成</li>
</ul>
<p><code>reducers</code>可以通过将新数据合并到它们管理的状态并重置isFetching来处理此操作。 UI将隐藏微调框，并显示提取的数据。</p>
<ul>
<li><strong>An action informing the reducers that the request failed.</strong>通知<code>reducers</code>请求失败。</li>
</ul>
<p>reducer可以通过重置isFetching来处理此操作。此外，一些reducer可能希望存储错误消息，以便UI可以显示它。</p>
<h3 id="创建同步Action-Synchronous-Action-Creators"><a href="#创建同步Action-Synchronous-Action-Creators" class="headerlink" title="创建同步Action Synchronous Action Creators"></a>创建同步Action Synchronous Action Creators</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/07/Generator/" itemprop="url">
                  Generator学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-07T15:13:34+08:00" content="2016-11-07">
              2016-11-07
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>Generator可以理解为一个状态机，封装了多个内部状态</p>
</li>
<li><p>执行Genertaor函数会返回一个遍历器对象。</p>
</li>
<li><p>特征</p>
<ul>
<li><code>function</code>关键字和函数名之间有一个*</li>
<li>函数内部使用<code>yield</code>语句，用来定义不同状态。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</div><div class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</div><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></div><div class="line"></div><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></div><div class="line"></div><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></div><div class="line"></div><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure>
<p><code>Generator</code>函数调用不会执行，返回的是指向内部状态的指针对象。</p>
<p>调用遍历器对象的<code>next</code>方法，使指针移向下移状态。</p>
<p>每次调用<code>next</code>内部指针（执行流）从函数头部或者上次停止地方开始执行，直到下一个<code>yield</code>语句（或<code>return</code>）。</p>
</li>
</ul>
<h2 id="yield语句"><a href="#yield语句" class="headerlink" title="yield语句"></a>yield语句</h2><ul>
<li><code>next</code>调用时<ul>
<li>执行到<code>yield</code>语句，暂停执行后面操作<code>yield</code>后表达之，作为返回的对象和的<code>value</code></li>
<li>再次调用<code>yield</code>继续向下执行，直到下一个<code>yield</code>语句</li>
<li>执行到<code>return</code>语句，将<code>return</code>语句后表达式的值，作为返回对象的<code>value</code></li>
<li>函数没有<code>return</code>，返回<code>value</code>为<code>undefined</code></li>
<li><code>yield</code>语句后的表达式，调用时才会执行（惰性求值Lazy Evaluation）</li>
</ul>
</li>
<li><code>yield</code>与<code>return</code><ul>
<li>都返回之后表达式的值</li>
<li>一个函数只能有一个<code>return</code>，可以多个<code>yield</code></li>
<li><code>yield</code>不能在普通函数中使用</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/28/计算机网络概论/" itemprop="url">
                  学习笔记——网络架构与七层参考模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-28T09:47:52+08:00" content="2016-10-28">
              2016-10-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机网络概论——网络基础"><a href="#计算机网络概论——网络基础" class="headerlink" title="计算机网络概论——网络基础"></a>计算机网络概论——网络基础</h1><h2 id="网络概览"><a href="#网络概览" class="headerlink" title="网络概览"></a>网络概览</h2><h3 id="Applications应用"><a href="#Applications应用" class="headerlink" title="Applications应用"></a>Applications应用</h3><p>通常人们如何通过什么途径认识网络？</p>
<ul>
<li>浏览器</li>
<li>在线游戏</li>
<li>Email</li>
<li>社交网络</li>
<li>网络串流</li>
<li>文件分享</li>
<li>即时通讯</li>
</ul>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><ul>
<li>URL(Uniform resource locater)</li>
<li>HTTP(Hyper Text Transfer Protocol)</li>
<li>TCP(Transmission Control Protocol)</li>
</ul>
<p>一次URL请求大概需要17次message？</p>
<ul>
<li>6个找到IP地址</li>
<li>3次握手 TCP</li>
<li>4次 HTTP</li>
<li>4次 tearing down(取消)TCP</li>
</ul>
<h3 id="网络链接Network-Connectivity"><a href="#网络链接Network-Connectivity" class="headerlink" title="网络链接Network Connectivity"></a>网络链接Network Connectivity</h3><h4 id="重要名词-Important-terminologies"><a href="#重要名词-Important-terminologies" class="headerlink" title="重要名词 Important terminologies"></a>重要名词 Important terminologies</h4><ul>
<li>Link(设备连接 有线/无线)</li>
<li>Nodes(设备 电/手机)</li>
<li>Point-to-point(点对点)</li>
<li>Multiple access(两个以上的连接)</li>
<li>Switched Network(交换网络)<ul>
<li>Circult Switched(线路交换)</li>
<li>Packet Switched(数据包交换)</li>
</ul>
</li>
<li>Packet,message</li>
<li>Store-and-foward</li>
</ul>
<h4 id="Terminologies"><a href="#Terminologies" class="headerlink" title="Terminologies"></a>Terminologies</h4><ul>
<li>Host(主机)</li>
<li>Switches(交换机)</li>
<li>Spanning tree(生成树协议)</li>
<li>internetwork(互联网)</li>
<li>Router/gateway(路由器)</li>
<li>Host-to-host connectivity(终端对终端连接)</li>
<li>Address</li>
<li>Routing(路由)</li>
<li>Unicats/broadcats/multicast(特定对象/广播/多个)<ul>
<li>broadcats通常会被Router拦截</li>
</ul>
</li>
<li>LAN(Local Area Networks 局域网)</li>
<li>MAN(Metropolitan Area Networks 城域网)</li>
<li>WAN(Wide Area Networks 广域网)</li>
</ul>
<h4 id="数据元是如何在互联网上被传输的？How-datagrams-are-delivered-in-an-Internet"><a href="#数据元是如何在互联网上被传输的？How-datagrams-are-delivered-in-an-Internet" class="headerlink" title="数据元是如何在互联网上被传输的？How datagrams are delivered in an Internet?"></a>数据元是如何在互联网上被传输的？How datagrams are delivered in an Internet?</h4><p>路由器之间会交换彼此网络状态，数据元会根据状态自动调整传输路线。</p>
<p>路由器可以将fragment（封包切分），当封包超过大小上限值的时候会被fragment。</p>
<p>每一个小的封包都具备完整的地址信息，可以被独立传送。</p>
<p>每一个小的封包都是独立的，所以每个小封包的路径可能会不一样，这样造成封包未必会按照顺序到达接受的Nodes</p>
<p>当封包过多次被Routing没有送达会被Router丢弃，就会存在丢包</p>
<h4 id="合理的资源分配Cost-Effective-Resource-Sharing"><a href="#合理的资源分配Cost-Effective-Resource-Sharing" class="headerlink" title="合理的资源分配Cost-Effective Resource Sharing"></a>合理的资源分配Cost-Effective Resource Sharing</h4><ul>
<li>resource资源：links and nodes</li>
<li>How to share a link?<ul>
<li>Multiolexing(多个input共用一个links进行output)</li>
<li>De-multiplexing</li>
</ul>
</li>
</ul>
<h5 id="FDM-Frequency-Division-Multiplexing-频道分割"><a href="#FDM-Frequency-Division-Multiplexing-频道分割" class="headerlink" title="FDM: Frequency Division Multiplexing 频道分割"></a>FDM: Frequency Division Multiplexing 频道分割</h5><h5 id="TDM：Time-division-Multiplexing-时间分割"><a href="#TDM：Time-division-Multiplexing-时间分割" class="headerlink" title="TDM：Time-division Multiplexing 时间分割"></a>TDM：Time-division Multiplexing 时间分割</h5><h5 id="Statistical-Multiplexing-统计多工"><a href="#Statistical-Multiplexing-统计多工" class="headerlink" title="Statistical Multiplexing 统计多工"></a>Statistical Multiplexing 统计多工</h5><ul>
<li>Data is transmitted based on demand of each flow</li>
<li>FIFO先进先出， Round-Robin轮流，Priorities(Quality-of-Service(Qos)重要优先)</li>
</ul>
<h4 id="Logical-Channels-逻辑频道"><a href="#Logical-Channels-逻辑频道" class="headerlink" title="Logical Channels 逻辑频道"></a>Logical Channels 逻辑频道</h4><p>两个Host的连接，就叫做Logical Channel</p>
<h4 id="Network-Reliability-网络可靠性"><a href="#Network-Reliability-网络可靠性" class="headerlink" title="Network Reliability 网络可靠性"></a>Network Reliability 网络可靠性</h4><ul>
<li>网络应该隐藏错误</li>
<li>Bits 丢失/错误<ul>
<li>Bits error收到电场电磁波干扰，会出错（1，0错误）</li>
<li>大量Bits错误，Burst errors。</li>
<li>无法纠错会丢包</li>
</ul>
</li>
<li>Packets are lost (Congestion)网络阻塞</li>
<li>Links and Node failures</li>
<li>Messages are delayed 延迟</li>
<li>Messages are delivered out-of-order 封包顺序错乱</li>
<li>Third parties eaves drop 第三次篡改</li>
</ul>
<h2 id="Network-Architecture-网络体系结构"><a href="#Network-Architecture-网络体系结构" class="headerlink" title="Network Architecture 网络体系结构"></a>Network Architecture 网络体系结构</h2><h3 id="Protocols-协议"><a href="#Protocols-协议" class="headerlink" title="Protocols 协议"></a>Protocols 协议</h3><ul>
<li>定义横向通信规范<ul>
<li>peer system</li>
</ul>
</li>
<li>上层协议需要下层提供服务</li>
<li>Building blocks of a network arch architecture </li>
<li>每个协议有两个 interfaces<ul>
<li>Service interface 为上层提供服务</li>
<li>Peer-to-Peer interface 对等网络</li>
</ul>
</li>
</ul>
<h4 id="Protocols-interface-协议接口"><a href="#Protocols-interface-协议接口" class="headerlink" title="Protocols interface 协议接口"></a>Protocols interface 协议接口</h4><ul>
<li>横向<ul>
<li>格式</li>
<li>流程</li>
</ul>
</li>
<li>纵向<ul>
<li>提供不同服务</li>
</ul>
</li>
</ul>
<h4 id="Protocols-特点"><a href="#Protocols-特点" class="headerlink" title="Protocols 特点"></a>Protocols 特点</h4><ul>
<li>Protocols Specification 协议规格</li>
<li>Interoperable 可以互通</li>
<li>IETF 制定协议</li>
</ul>
<h4 id="Protocol-Architecture-协议结构"><a href="#Protocol-Architecture-协议结构" class="headerlink" title="Protocol Architecture 协议结构"></a>Protocol Architecture 协议结构</h4><p>下层服务加值提供给上层协议服务</p>
<h2 id="开放系统互连架构-OSA-Open-Systems-Interconnection-Architecture"><a href="#开放系统互连架构-OSA-Open-Systems-Interconnection-Architecture" class="headerlink" title="开放系统互连架构 OSA(Open Systems Interconnection)  Architecture"></a>开放系统互连架构 OSA(Open Systems Interconnection)  Architecture</h2><h3 id="结构分层"><a href="#结构分层" class="headerlink" title="结构分层"></a>结构分层</h3><ul>
<li>Application 应用层</li>
<li>Presentation 表现层/呈现层</li>
<li>Session 会话层</li>
<li>Transport 传输层<ul>
<li>负责分类不同服务</li>
<li>TCP/UTP</li>
<li>只有两端host有</li>
</ul>
</li>
<li>Network 网络层<ul>
<li>如何送给对方host</li>
<li>IP</li>
</ul>
</li>
<li>Data Link 数据链路层<ul>
<li>如何传输数据给下一个Router(下一步)</li>
</ul>
</li>
<li>Physical 物理层<ul>
<li>电缆，光纤，无线网络</li>
<li>如何传输信号</li>
</ul>
</li>
</ul>
<h3 id="Host如何和Router链接"><a href="#Host如何和Router链接" class="headerlink" title="Host如何和Router链接"></a>Host如何和Router链接</h3><p>Host =&gt; LAN(交换机) =&gt; Router</p>
<p>交换机只解析到Data Link链路层</p>
<p>链路层传输依靠物理层网卡位置信息</p>
<p>设备可以处理第几层，就是第几层的设备。</p>
<h3 id="网络分层描述-Description-of-Layers"><a href="#网络分层描述-Description-of-Layers" class="headerlink" title="网络分层描述 Description of Layers"></a>网络分层描述 Description of Layers</h3><ul>
<li><h4 id="Physical-Layer-物理层-如何在Link上传输"><a href="#Physical-Layer-物理层-如何在Link上传输" class="headerlink" title="Physical Layer 物理层 如何在Link上传输"></a>Physical Layer 物理层 如何在Link上传输</h4><ul>
<li>Coaxial cable 同轴电缆<ul>
<li>Twisted pair 双绞线（搅在一起降低电磁干扰，8条线）</li>
<li>Optical Fiber 光纤 （不受电磁波干扰， 传输距离远）</li>
<li>Air space 电磁波 (wireless radio channel) </li>
</ul>
</li>
<li>Different Signal Coding schems 不同编码<ul>
<li>发送和接受要求速率相同</li>
<li>不同材料不同coding</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="Data-Link-Layer-链路层-如何将frame传给直接相连的主机或者设备"><a href="#Data-Link-Layer-链路层-如何将frame传给直接相连的主机或者设备" class="headerlink" title="Data Link Layer 链路层 (如何将frame传给直接相连的主机或者设备)"></a>Data Link Layer 链路层 (如何将frame传给直接相连的主机或者设备)</h4><ul>
<li>Collects a streame of bits into a <code>frame</code></li>
<li>How to transmit a frame to a directly connected host (destination)?</li>
<li>MAC(Media Access Control Protocol) 媒体访问控制<ul>
<li>CSMA/CD(IEEE 802.3 Ethernet) 监听是否有正在传输</li>
<li>CSMA/CA(IEEE 802.11 Wireless LAN)</li>
</ul>
</li>
<li>Layer 2 devlces 2层设备</li>
<li>Switches 交换机   </li>
<li>Bridges</li>
</ul>
</li>
<li><h4 id="Network-Layer-网络层-如何将封包送到目的地主机"><a href="#Network-Layer-网络层-如何将封包送到目的地主机" class="headerlink" title="Network Layer 网络层 (如何将封包送到目的地主机)"></a>Network Layer 网络层 (如何将封包送到目的地主机)</h4><ul>
<li>IP to IP</li>
<li>How to transmit frames to a host via the Internet?</li>
<li>Handle <code>routing</code> among nodes within a packet-switched network</li>
<li>Data exchanged between</li>
<li>IP protocol不可靠服务</li>
<li>Router之间互通状态，</li>
<li>Routing protocols 为了动态选择路径，依靠的protocol。网络层最重要的内容<ul>
<li>RIP  第一代协议，每30秒交换一次状态</li>
<li>OSPF  会寻找最短路径</li>
<li>BGP </li>
</ul>
</li>
<li>Routing Tables 路由状态信息会存入Routing Tables<ul>
<li>Routing Tables 自身是动态维护的，所以Table的信息是会变的</li>
<li>收到封包，获得header，根据ip查询Routing Tables，传递给下一个Router</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="Transport-Layer-提供不同主机processes之间的数据传输"><a href="#Transport-Layer-提供不同主机processes之间的数据传输" class="headerlink" title="Transport Layer(提供不同主机processes之间的数据传输)"></a>Transport Layer(提供不同主机processes之间的数据传输)</h4><ul>
<li>Implements a <code>process-to-process</code> channer</li>
<li>Unit of data exchanges in this layer is called a message</li>
<li>TCP(Transmission Control Protocol) - Reliable service 可靠服务</li>
<li>UCP(User Datagram Protocol) - Unreliable service 不可靠服务</li>
</ul>
</li>
<li><h4 id="Session-Layer-会话层"><a href="#Session-Layer-会话层" class="headerlink" title="Session Layer 会话层"></a>Session Layer 会话层</h4><ul>
<li>Provides a name space that is used <code>to tie together the potentially different transport streams</code>that are part of a single application</li>
<li>将不同的streames汇合为一起</li>
</ul>
</li>
<li><h4 id="Presentation-Layer-表现层-呈现层"><a href="#Presentation-Layer-表现层-呈现层" class="headerlink" title="Presentation Layer 表现层/呈现层"></a>Presentation Layer 表现层/呈现层</h4><ul>
<li>Concerned about the <code>format of data</code> exchanged between peers</li>
<li>双方数据的格式标准</li>
</ul>
</li>
<li><h4 id="Application-Layer-应用层"><a href="#Application-Layer-应用层" class="headerlink" title="Application Layer 应用层"></a>Application Layer 应用层</h4><ul>
<li>Standardize common type of exchanges</li>
<li>FTP/E-mail/DNS/HTTP/Browsers..</li>
</ul>
</li>
</ul>
<p>Host有7层，Router只有传输层以下三层，交换机只有物理层和链路层</p>
<p>实际上使用中并不严格按照7层来，可以跳过中间的层。</p>
<h2 id="网络性能Network-Performance"><a href="#网络性能Network-Performance" class="headerlink" title="网络性能Network Performance"></a>网络性能Network Performance</h2><ul>
<li>频宽 Bandwidth<ul>
<li>`Number of bits per second</li>
</ul>
</li>
<li>1Mbps: 1 * 10^6 bits/second</li>
<li>速度越快，bit宽度越窄</li>
<li>信号传递时间 + 传输资料的时间 + queuing time<ul>
<li>距离/速度</li>
<li>size大小/bandwidth频宽</li>
</ul>
</li>
<li>问题<ul>
<li>传输完，前导资料未到（）</li>
<li>传输为完后才能，前导资料已到（transmission time）</li>
</ul>
</li>
</ul>
<h3 id="Delay-X-Bandwidth"><a href="#Delay-X-Bandwidth" class="headerlink" title="Delay X Bandwidth"></a>Delay X Bandwidth</h3><ul>
<li>Delay X Bandwidth  = pipe full 的资料量</li>
<li>Bandwidth 和 latency 哪个重要<ul>
<li>大档案传输Bandwidth重要</li>
<li>小资料latency更重要</li>
<li>latency的动态 jitter jitter越大越不稳定</li>
</ul>
</li>
<li>在停下来等对方回应之前能够传输最多的资料量</li>
</ul>
<h3 id="Throughput"><a href="#Throughput" class="headerlink" title="Throughput"></a>Throughput</h3><ul>
<li>RTT(Round Trip Time) dominates</li>
<li>Throughput = TransferSize/TransferTime </li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/27/gulp-util/" itemprop="url">
                  学习笔记——gulp-util
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-27T20:12:01+08:00" content="2016-10-27">
              2016-10-27
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="gulp-util"><a href="#gulp-util" class="headerlink" title="gulp-util"></a>gulp-util</h1><p>gulp的实用功能插件</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gutil = <span class="built_in">require</span>(<span class="string">'gulp-util'</span>);</div><div class="line"> </div><div class="line">gutil.log(<span class="string">'stuff happened'</span>, <span class="string">'Really it did'</span>, gutil.colors.magenta(<span class="string">'123'</span>));</div><div class="line">gutil.beep();</div><div class="line"> </div><div class="line">gutil.replaceExtension(<span class="string">'file.coffee'</span>, <span class="string">'.js'</span>); <span class="comment">// file.js </span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> opt = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'todd'</span>,</div><div class="line">  <span class="attr">file</span>: someGulpFile</div><div class="line">&#125;;</div><div class="line">gutil.template(<span class="string">'test &lt;%= name %&gt; &lt;%= file.path %&gt;'</span>, opt) <span class="comment">// test todd /js/hi.js</span></div></pre></td></tr></table></figure>
<h3 id="log-msg…"><a href="#log-msg…" class="headerlink" title="log(msg…)"></a>log(msg…)</h3><h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p> <a href="https://github.com/sindresorhus/chalk" target="_blank" rel="external">chalk</a>的实例</p>
<h3 id="replaceExtension-path-newExtension"><a href="#replaceExtension-path-newExtension" class="headerlink" title="replaceExtension(path, newExtension)"></a>replaceExtension(path, newExtension)</h3><p>替换路径中文件的后缀名，返回一个新的路径。</p>
<h3 id="isStream-obj"><a href="#isStream-obj" class="headerlink" title="isStream(obj)"></a>isStream(obj)</h3><p>判断一个对象是不是一个stream，返回布尔值。</p>
<h3 id="isBuffer-obj"><a href="#isBuffer-obj" class="headerlink" title="isBuffer(obj)"></a>isBuffer(obj)</h3><p>判断一个对象是不是一个Buffer，返回布尔值。</p>
<h3 id="template-string-data"><a href="#template-string-data" class="headerlink" title="template(string[,data])"></a>template(string[,data])</h3><p>这是一个封装的lodash.template函数。你不洗在一个</p>
<p>这是一个lodash.template函数包装。你必须传入有效的gulp文件对象，才能提供给给用户，否则会报错。您不能配置任何分隔符。看<a href="http://lodash.com/docs#template" target="_blank" rel="external">lodash</a>文档的获得更多信息。</p>
<h3 id="new-File-obj"><a href="#new-File-obj" class="headerlink" title="new File(obj)"></a>new File(obj)</h3><p>参见 <a href="https://github.com/wearefractal/vinyl" target="_blank" rel="external">vinyl</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> file = <span class="keyword">new</span> gutil.File(&#123;</div><div class="line">  <span class="attr">base</span>: path.join(__dirname, <span class="string">'./fixtures/'</span>),</div><div class="line">  <span class="attr">cwd</span>: __dirname,</div><div class="line">  <span class="attr">path</span>: path.join(__dirname, <span class="string">'./fixtures/test.coffee'</span>)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="noop"><a href="#noop" class="headerlink" title="noop()"></a>noop()</h3><p>返回一个数据流，直接传输数据但是不进行任何操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// gulp should be called like this : </span></div><div class="line"><span class="comment">// $ gulp --type production </span></div><div class="line">gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  gulp.src(<span class="string">'src/**/*.js'</span>)</div><div class="line">    .pipe(concat(<span class="string">'script.js'</span>))</div><div class="line">    .pipe(gutil.env.type === <span class="string">'production'</span> ? uglify() : gutil.noop())</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="buffer-cb"><a href="#buffer-cb" class="headerlink" title="buffer(cb)"></a>buffer(cb)</h3><p>这类似于es.wait但不是缓冲文到string,而是缓冲区任何东西到一个数组（所以对于文件对象是非常有用的）。</p>
<p>返回一个可以供pipe的数据流</p>
<p>Stream竟会触发一个数据事件，将stream通过管道输送直到传输完毕。数据会像一个数组一样被传输到callback</p>
<p>Callback是可选的，接收两个参数：错误和数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'stuff/*.js'</span>)</div><div class="line">  .pipe(gutil.buffer(<span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>) </span>&#123;</div><div class="line">  </div><div class="line">  &#125;));</div></pre></td></tr></table></figure>
<h3 id="new-PluginError-pluginName-message-options"><a href="#new-PluginError-pluginName-message-options" class="headerlink" title="new PluginError(pluginName, message[,options])"></a>new PluginError(pluginName, message[,options])</h3><ul>
<li>pluginName应该是你的插件的模块名称</li>
<li>message可以是string或者现有error</li>
<li>默认情况下，栈将不会显示。如果你认为堆栈为你的错误很重要设置options.showStack为true。</li>
<li>如果你在为堆栈将从被拉消息传递一个错误，否则将创建一个。</li>
<li>需要注意的是，如果你在一个自定义堆栈字符串传递需要包括沿消息。</li>
<li>错误属性将被包括在<code>err.toString()</code>。可以通过包括省略<code>{showProperties: false}</code>在选项。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> gutil.PluginError(<span class="string">'test'</span>, &#123;</div><div class="line">  <span class="attr">message</span>: <span class="string">'something broke'</span></div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> gutil.PluginError(&#123;</div><div class="line">  <span class="attr">plugin</span>: <span class="string">'test'</span>,</div><div class="line">  <span class="attr">message</span>: <span class="string">'something broke'</span></div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> gutil.PluginError(<span class="string">'test'</span>, <span class="string">'something broke'</span>);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> gutil.PluginError(<span class="string">'test'</span>, <span class="string">'something broke'</span>, &#123;<span class="attr">showStack</span>: <span class="literal">true</span>&#125;);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> existingError = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'OMG'</span>);</div><div class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> gutil.PluginError(<span class="string">'test'</span>, existingError, &#123;<span class="attr">showStack</span>: <span class="literal">true</span>&#125;);</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/26/JS读书笔记——函数/" itemprop="url">
                  JS学习笔记——函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-26T18:48:26+08:00" content="2016-10-26">
              2016-10-26
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JavaScript学习笔记——函数"><a href="#JavaScript学习笔记——函数" class="headerlink" title="JavaScript学习笔记——函数"></a>JavaScript学习笔记——函数</h1><h2 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h2><p>通过函数可以封装任意多条语句，而且可以在任何地方，任何时候调用执行。</p>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>JavaScript中的函数就是对象。函数对象连接到<code>Function.prototype</code>该原型对象本身连接到<code>Object.prototpye</code>）。</p>
<p>每个函数在创建时会附加两个隐藏属性：函数的上下文和实现函数行为的代码（当JavaScript创建一个函数对象的时候，会给该对象设置一个”调用“属性。详见ECMAScript规范的”13.2 Creating Function Objects“）</p>
<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><h3 id="函数声明语句"><a href="#函数声明语句" class="headerlink" title="函数声明语句"></a>函数声明语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi!'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="函数定义表达式"><a href="#函数定义表达式" class="headerlink" title="函数定义表达式"></a>函数定义表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sayYes = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'Yse!'</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sayHello = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'Hello!'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="两种定义方式的区别"><a href="#两种定义方式的区别" class="headerlink" title="两种定义方式的区别"></a>两种定义方式的区别</h3><ul>
<li>函数名：以声明式方式定义的函数，实际上声明了一个变量并把函数对象赋值给它。 而以表达式方式定义的函数，函数名是可选的。如果一个函数定义表达式包含名称，函数的名称将成为函数内部的一个局部变量。</li>
<li>声明提前：以声明式方式定义的函数，函数声明语句”被提前“到外部脚本或者外部函数作用域的顶部，所以可以被在它定义之前的代码调用。而函数定义表达式，会先声明一个变量，被声明的变量也会提前。但是在代码未执行完将函数赋值个这个变量的操作之前。这个函数是无法被调用的。</li>
</ul>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>JavasScript中函数定义并不需要指定函数形参的类型，函数调用也不会对实参进行任何类型检查，甚至实参和形参个数不同也不会出现问题。原因是ECMAScript中的参数在内部是使用一个类数组的<code>arguments</code>对象来表示的。</p>
<h3 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h3><p>当调用函数时传入的实参比函数声明时指定的形参个数要少的时候，剩下的形参都会被设置为<code>undefined</code>。</p>
<p>可以通过判断<code>if</code>语句或者<code>||</code>运算符来实现参数的可选。</p>
<h3 id="实参、实参对象"><a href="#实参、实参对象" class="headerlink" title="实参、实参对象"></a>实参、实参对象</h3><p>当调用函数时传入实参个数超过形参，没有办法直接获得未命名值的引用。而使用实参对象<code>arguments</code>可以解决这个问题。在函数体内<code>arguments</code>是指向实参对象的引用</p>
<p><code>arguments</code>是一个类数组对象，可以通过数字下标获得传入函数的实参值。</p>
<p>在严格模式下和ECMAScript 5标准中，<code>arguments</code>是只读的。</p>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><h2 id="函数的4种调用模式"><a href="#函数的4种调用模式" class="headerlink" title="函数的4种调用模式"></a>函数的4种调用模式</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/29/React教程/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-29T10:11:43+08:00" content="2016-09-29">
              2016-09-29
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p>我们将构建一个简单但好用的评论框，一个类似于Disqus，LiveFyre或Facebook评论的实时评论基本版本。</p>
<p>我们将提供：</p>
<ul>
<li>展示所有评论的视图</li>
<li>提交评论的表单</li>
<li>为你提供服务的自定义后端</li>
<li>Hooks for you to provide a custom backend</li>
</ul>
<p>将要实现的简单功能</p>
<ul>
<li>开放评论：评论在保存到服务器之前会出现在评论列表中，所以会感觉速度很快。</li>
<li>实时更新：其他用户的评论将会被实时更新到评论列表中。</li>
<li>支持MakeDown：用户可以使用MakeDown编辑文本</li>
</ul>
<h2 id="想要跳过这一切，只看源码？"><a href="#想要跳过这一切，只看源码？" class="headerlink" title="想要跳过这一切，只看源码？"></a>想要跳过这一切，只看源码？</h2><p><a href="https://github.com/reactjs/react-tutorial" target="_blank" rel="external">一切都在Github上</a></p>
<h2 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h2><p>为了开始教程，我们需要一个运行的服务器。这个服务器只会为我们提供用于获取和保存数据的API。为了让这一切更容易，我们已经通过一些脚本语言创建了我们需要的一个简单的服务器，您可以[查看源代码]或者[下载一个压缩文件]，里面包含开成教程的一切代码。</p>
<p>为了简单起见，我们将在服务器上使用一个<code>JSON</code>文件作为模拟数据库。你不会在工作中用到这一点（以JSON作为数据库）,但是他能很容易的模拟一个API让你使用。一旦你启动服务器，它将为我们的静态页面提供API。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>在本教程中，我们会尽量让一切变得容易。上面提到的服务器软件包包含了一个HTML文件，我们将要在这个文件中进行我们的工作。用你喜欢的编辑器打开<code>public/index.html</code>文件。它应该是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React Tutorial<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://npmcdn.com/react@15.3.1/dist/react.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://npmcdn.com/react-dom@15.3.1/dist/react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://npmcdn.com/babel-core@5.8.38/browser.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://npmcdn.com/jquery@3.1.0/dist/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://npmcdn.com/remarkable@1.6.2/dist/remarkable.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span> <span class="attr">src</span>=<span class="string">"scripts/example.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="javascript"></span></div><div class="line">      <span class="comment">// To get started with this tutorial running your own code, simply remove</span></div><div class="line">      <span class="comment">// the script tag loading scripts/example.js and start writing code here.</span></div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>对于本教程的其余部分，我们将在这个脚本标签来写我们的JsvaScript代码。我们没有使用任何先进的实时重载，所以你需要在保存后刷新浏览器才能看到更新。打开浏览器后地址栏输入<code>http://localhost:3000</code>（启动服务后）。当你第一次加载这个页面是看不到任何变化的，之后你将会看到我们构建结束后的效果。当你准好了要开始工作的时候，只要删除前面的<code>&lt;script&gt;</code>标签，然后就可以继续了。</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>我们这里引入了jQuery，因为我们希望能够简化我们调用AJAX的代码，但它并不是React运行必须的。</p>
<h2 id="你的第一个组件"><a href="#你的第一个组件" class="headerlink" title="你的第一个组件"></a>你的第一个组件</h2><p>React通过可组合的组件进行模块化的。对于我们评论框的列子，组成结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- CommentBox</div><div class="line">  - CommentList</div><div class="line">    - Comment</div><div class="line">  - CommentForm</div></pre></td></tr></table></figure>
<p>让我们创建<code>CommentBox</code>组件，它仅仅是一个简单的<code>&lt;div&gt;</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial1.js</span></div><div class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"commentBox"</span>&gt;</span></span></div><div class="line">        Hello, world! I am a CommentBox.</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">CommentBox</span> /&gt;</span>,</span></div><div class="line">  document.getElementById('content')</div><div class="line">);</div></pre></td></tr></table></figure>
<p>需要注意的是HTML原生的元素名称以小写字母开头，而自定义的React组件标签以大写字母开头。</p>
<h4 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h4><p>你会注意到的第一件事是在你的JavaScript中有XML的语法。我们有一个简单的预编译器会将这样的语法糖编译成普通的JavaScript：（这段代码展示是如何编译JSX的）</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial1-raw.js</span></div><div class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;<span class="attr">displayName</span>: <span class="string">'CommentBox'</span>,</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      React.createElement(<span class="string">'div'</span>, &#123;<span class="attr">className</span>: <span class="string">"commentBox"</span>&#125;,</div><div class="line">        <span class="string">"Hello, world! I am a CommentBox."</span></div><div class="line">      )</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(</div><div class="line">  React.createElement(CommentBox, <span class="literal">null</span>),</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>它的使用是可选的，但是我们发现比起普通JavaScript,使用JSX语法会更简单。了解更多关于<a href="http://reactjs.cn/react/docs/jsx-in-depth.html" target="_blank" rel="external">JSX语法文章</a>。</p>
<h5 id="这是怎么回事"><a href="#这是怎么回事" class="headerlink" title="这是怎么回事"></a>这是怎么回事</h5><p>我们通过JavaScript对象的一些方法<code>React.createClass()</code>创建一个新的React组件。最重要的，会通过<code>render</code>方法将React组件返回到HTML中渲染。</p>
<p>该<code>&lt;div&gt;</code>不是实际的DOM节点；they are instantiations of React components.他们是React的实例组件。You can think of these as markers or ！pieces！ of data that React knows how to handle.你可以认为这是一种标记，React知道如何处理的数据。我们生成的不是HTML字符串，所以是可以防止XSS攻击的。</p>
<p>你不用返回基本的HTML。You can return a tree of components that you (or someone else) built.你可以返回你（或者其他人）构建的组件。This is what makes React composable : a key tenet of maintainable frontends.这就是为什么React可以组件化，一种方便维护的前端的关键原则。<code>ReactDOM.render()</code>方法第二个参数，实例根组件，启动框架，同时将组件注入原生DOM元素中。</p>
<p><em>ReactDOM</em>模块暴露出特定的DOM相关的方法， while has the core tools shared by React on different platforms (e.g., React Native).同时<em>React</em>拥有不同的核心工具 || React对于不同的平台（例如：[ReactNative]），React共享同样的核心工具。</p>
<p>It is important that remain at the bottom of the script for this tutorial. should only be called after the composite components have been defined.很重要的一点，<code>ReactDOM.render</code>要放在script中的底部。<code>ReactDOM.render</code>方法必须在确定组件组合完毕后才能调用。</p>
<h1 id="撰写组件"><a href="#撰写组件" class="headerlink" title="撰写组件"></a>撰写组件</h1><p>Let’s build skeletons for and which will, again, be simple s.让我们再次通过简单的<code>&lt;div&gt;</code>来构建<code>CommentList</code>和<code>CommentForm</code>的骨架。将这两个组件添加到您的文件中，保留<code>CommentBox</code>的声明和<code>ReactDOM.render</code>的调用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial2.js</span></div><div class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"commentList"</span>&gt;</span></span></div><div class="line">        Hello, world! I am a CommentList.</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> CommentForm = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"commentForm"</span>&gt;</span></span></div><div class="line">        Hello, world! I am a CommentForm.</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>下一步，在<code>CommentBox</code>组件中使用这些新组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial3.js</span></div><div class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"commentBox"</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Comments<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">CommentList</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">CommentForm</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>请注意，我们如何是将HTML标签和我们自己构建的组件一起使用的。HTML组件是常规的React组件，就像你平时使用的HTML一样，但是有一点不同。The JSX compiler will automatically rewrite HTML tags to expressions and leave everything else alone.JSX编译器会自动重写HTML标记，通过<code>React.createElement(tagName)</code>方法生成，并且是独一无二的。这是为了防止全局命名空间污染。</p>
<h2 id="使用props"><a href="#使用props" class="headerlink" title="使用props"></a>使用props</h2><p>通过父组件传递来的数据将会影响我们创建的<code>Comment</code>组件。Data passed in from a parent component is available as a ‘property’ on the child component.从父组件传递的数据对于子组件是可用的财产?These ‘properties’ are accessed through .这些”特性”通过访问this.props。使用props，我们能够从<code>CommentList</code>读取数据，传递给<code>Comment</code>， and render some markup:并渲染一些makeup，样式？标记？</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tutorial4.js</span></div><div class="line"><span class="keyword">var</span> Comment = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"comment"</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">"commentAuthor"</span>&gt;</span></div><div class="line">          &#123;this.props.author&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">        &#123;this.props.children&#125;</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>By surrounding a JavaScript expression in braces inside JSX (as either an attribute or child), you can drop text or React components into the tree.</p>
<p>在JSX中，可以通过括号中的JavaScript表达式（作为一个标签，属性或者子元素），你可以将文本或React组件插入到DOM树。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Zeno Tian" />
          <p class="site-author-name" itemprop="name">Zeno Tian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zenotian" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zeno Tian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

</body>
</html>
